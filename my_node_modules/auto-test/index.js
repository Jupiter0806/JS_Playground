/**
 * This project could scan files under the same directory and run all test in them. The test
 *  report could be print to the terminal or pass to the caller via Callback.
 * 
 * It Requires package of parse-commandline-arguments
 * 
 * How to write test:
 *  1. write test in other files and export all tests
 *  2. this file will scan this directory to find all tests and test them and
 *  3. print out test report if these are all reports, if not, callback the test results
 * 
 * How to run test
 *  There are two ways to run test:
 *      1. Run all test: node ./
 *      2. Run all test in one specific file: node ./ --only filename
 *      3. Run specific test in one specific file: node ./ --only filename:functions[,function2,function3,...]
 * 
 * To exclude files, add the filename in the excludeFiles. 
 * Do not delete 'index.js' as it should always be excluded.
 * 
 * todo: 
 *  1. in the final test report, failed messages should be formate in a proper way
 *  2. accept --path to find test in other directory
 */

const chalk = require('chalk')
const Promise = require('bluebird')

const { splitFilename, consolePrintTestResultsReportAndCallbackIfNeeded, TestResults } = require('./helpers')

const excludeFiles = ['index.js', 'config.js', 'helpers.js']

let testResultsCallback = null

let isOnlyMode = false
let only = {
    filename: '',
    functions: []
}

module.exports = {
    registerTestResultsCallback
}

// --only filename:function1,function2
const cmdargs = require('../parse-commandline-arguments').parseCommandlineArguments(process.argv, {only: ''})
if (cmdargs.only && cmdargs.only !== true) {
    params = cmdargs.only.split(':')
    isOnlyMode = true
    only.filename = params[0]
    only.functions = params[1] ? params[1].split(',') : []

    console.log(chalk.bgYellow.black("Only mode is on"))
    console.log("Only test file", chalk.bgCyan(only.filename), "for ", only.functions.length === 0 ? "all test functions" : "functions:" + JSON.stringify(only.functions))
}

require('fs').readdir('./', (error, items) => {
    if (!error) {
        let tests = {}
        let testResults = new TestResults()
        items.forEach(item => {
            if (excludeFiles.indexOf(item) < 0)  {
                const { filename, extension } = splitFilename(item)
                if (extension === 'js') {
                    if ((isOnlyMode && (only.filename === filename || only.filename === filename + '.js')) 
                            || !isOnlyMode) {
                        tests[filename] = require('./' + filename)
                        testResults.totalTest += Object.keys(tests[filename]).length
                    }
                    
                }
            }
        })
        if (!isOnlyMode) {
            console.log(chalk.cyan("Totally have " + testResults.totalTest + ' tests'))
        } else {
            console.log(chalk.cyan("Totally have no more than " + only.functions.length + ' tests'))
        }
        testResults.totalTest = 0 // totalTest should be count as the test running
        console.log("Start testing...")
        let promises = []
        Object.keys(tests).forEach(key => {
            promises.push(new Promise((resolve, reject) => {
                performTest(key, tests[key], (passed, failed, failedMessages) => {
                    if (isOnlyMode) {
                        // remove tested functions from the only.functions to know which one in only.functions does not test
                        passed.forEach(aPassed => {
                            only.functions.splice(only.functions.indexOf(aPassed), 1)
                        })

                        failed.forEach(aFailed => {
                            only.functions.splice(only.functions.indexOf(aFailed), 1)
                        })
                    }

                    testResults.passed[key] = passed
                    testResults.failed[key] = failed
                    testResults.passedCount += passed.length
                    testResults.failedCount += failed.length
                    testResults.totalTest += passed.length + failed.length
                    testResults.failedMessages[key] = failedMessages
                    resolve()
                })
            }))
        })
        Promise.all(promises).then(() => {
            if (only.functions.length > 0) {
                console.log(chalk.yellow('Cannot find these functions '), only.functions)
            }
            consolePrintTestResultsReportAndCallbackIfNeeded(testResults, testResultsCallback)
        })
    } else {
        console.log(chalk.red(JSON.stringify(error)))
    }
})

function performTest(testname, tests, callback) {
    const keys = Object.keys(tests)
    if (!isOnlyMode) {
        console.log("Start to test", testname , chalk.bgCyan(" having " + keys.length + " tests"))
    } else {
        console.log("Start to test", testname , chalk.bgCyan(" having no more than " + only.functions.length + " tests"))
    } 
    
    let testResults = {}

    let promises = []
    keys.forEach(key => {
        if ((isOnlyMode && ((only.functions.length > 0 && only.functions.indexOf(key) >=0)  || (only.functions.length <= 0))) 
            || (!isOnlyMode)) {
                promises.push(new Promise((resolve, rejct) => {
                    tests[key]((res, failedMessage) => {
                        testResults[key] = {res, failedMessage}
                        resolve()
                    })
                }))
            }
    })
    Promise.all(promises).then(() => {
        let passed = []
        let failed = []
        let failedMessages = {}
        Object.keys(testResults).forEach((key) => {
            if (testResults[key].res) {
                passed.push(key)
            } else {
                failed.push(key)
                if (testResults[key].failedMessage) {
                    failedMessages[key] = testResults[key].failedMessage
                }
            }
        })
        if (passed.length > 0) {
            console.log(chalk.green(testname + " passed:"))
            console.log(passed)
        }
        if (failed.length > 0) {
            console.log(chalk.red(testname + " failed:"))
            console.log(failed)
        }
        
        if (passed.length > 0) {
            console.log(chalk.green(testname + " subtotal " + passed.length + " passed"))
        }
        if (failed.length > 0) {
            console.log(chalk.red(testname + " subtotal " + failed.length + " failed"))
        }

        callback ? callback(passed, failed, failedMessages) : ''
    })
}

function registerTestResultsCallback(callback) {
    testResultsCallback = callback
}