const chalk = require('chalk')

function splitFilename(filename) {
    return {
        filename: filename.replace(/(?:\.([^.]+))?$/.exec(filename)[0], ''),
        extension: /(?:\.([^.]+))?$/.exec(filename)[1]
    }
}

function TestResults() {
    this.totalTest = 0
    this.passed = {}
    this.failed = {}
    this.passedCount = 0
    this.failedCount = 0
    this.failedMessages = {}
}

function consolePrintTestResultsReportAndCallbackIfNeeded(testResults, callback) {
    console.log(chalk.cyan("Totally tested " + testResults.totalTest))
    console.log(chalk.green(testResults.passedCount + " passed"))
    console.log(chalk.red(testResults.failedCount + " failed"), 
                    testResults.failedCount > 0 ? testResults.failed : '',
                    testResults.failedCount > 0  ? '\n' : '',
                    testResults.failedCount > 0 ? chalk.bgRed('Detailed Report') : '',
                    testResults.failedCount > 0 ? JSON.stringify(testResults.failedMessages, null, 4) : ''
                )

    callback ? callback(testResults) : allDone()

    function allDone() {
        if (testResults.totalTest === testResults.passedCount) {
            console.log(chalk.bgGreen("---All Passed---"))
        }
        process.exit()
    }
}

function compareTwoOject(obj1, obj2) {
    let res = true
    Object.keys(obj1).forEach(key => {
        if (obj1[key] !== obj2[key]) {
            res = false
        }
    })
    if (res) {
        Object.keys(obj2).forEach(key => {
            if (obj2[key] !== obj1[key]) {
                res = false
            }
        })
    }
    return true
}

function TestFunctionConfig (testClass, testfunc, parameters, expectError, prerunfuncs) {
    this.testClass = testClass || null // the class the test function belongs to 
    this.testfunc = testfunc || null // the test function name, if testClass is null, this should be a function
    this.parameters = parameters || [] // the parameters, expect callback, that need to pass to the test function
    this.expectError = expectError || null // any error this test function expect, should be one of ErrorHanlder.ERROR_STATUS
    this.prerunfuncs = prerunfuncs || [] // an array of TestFunctionConfig to specify any other functions need to be run before test, the order in the array will be the order the functions will be run
}

function readConfigAndRun(config, callback) {
    if (config instanceof TestFunctionConfig) {
        const { testClass, testfunc, parameters, expectError, prerunfuncs } = config
        if (prerunfuncs && prerunfuncs.length > 0) {
            test(prerunfuncs[0], (passed, error) => {
                if (passed) {
                    readConfigAndRun(
                        Object.assign(new TestFunctionConfig(), config, {prerunfuncs: prerunfuncs.slice(1)}), 
                        callback)
                } else {
                    callback(false, JSON.stringify(error))
                }
            }, prerunfuncs[0].testfunc)
        } else {
            test(config, callback)
        } 
    } else {
        console.log(chalk.red('Wrong test function config'))
        callback(false, 'Wrong test function config')
    }
}

/**
 * 
 * @param {Object} config 
 * @param {function} callback 
 * @param {bool} isPrerunfunc to say this function is called by pre run mode which means it does not need to print out some line
 */
function test(config, callback, prerunfunc) {
    const {
        testClass,
        testfunc,
        parameters,
        expectError
    } = config

    callback = callback || fallbackCallback
    
    let func = null
    if (testClass) {
        if (testClass[testfunc]) {
            func = testClass[testfunc]
        } else {
            callback(false, 'Cannot find function ' + testfunc + '. You may forget to export it')
        }
    } else {
        // testClass is null, so the testfunc should be function
        typeof testfunc === 'function' ? func = testfunc : callback(false, 'If no test testClass passed as parameter, testfunc should be a function')
    }

    if (func) {
        func(...parameters, error => {
            if (!error) {
                if (expectError) {
                    console.log(chalk.red((prerunfunc ? "Test prerunfunc:" : '') + testfunc + " expect " + expectError + ' failed due to'), 'received no error')
                    callback(false, testfunc + " expect " + expectError + ' failed due to received no error')
                } else {
                    if (!prerunfunc) {
                        console.log(chalk.green((prerunfunc ? "Test prerunfunc:" : '') + (typeof testfunc === 'function' ? 'anonymous function test' : testfunc) + ' passed'))
                    }
                    callback(true)
                }
            } else {
                if (expectError) {
                    if (expectError === error.Status) {
                        if (!prerunfunc) {
                            console.log(chalk.green(testfunc + ' passed'))
                        }
                        callback(true)
                    } else {
                        console.log(chalk.red((prerunfunc ? "Test prerunfunc:" : '') + testfunc + ' expect ' + expectError + ' failed due to'), 'received other error', error)
                        callback(false, (prerunfunc ? "Test prerunfunc:" : '') + testfunc + ' expect ' + expectError + ' failed due to received other error' + JSON.stringify(error))
                    }
                } else {
                    console.log(chalk.red((prerunfunc ? "Test prerunfunc:" : '') + testfunc + ' failed due to '), error)
                    console.log(callback)
                    callback(false, (prerunfunc ? "Test prerunfunc:" : '') + testfunc + ' failed due to ' + JSON.stringify(error))
                }
            }
        })
    }
}

function fallbackCallback(res, message) {
    console.log('Test', res ? chalk.green('passed') : chalk.red('failed') + ' with message "' + message + '".', 'You may not find the test final report because cannot find callback function. Please make sure to pass callback in your test functions')
}

module.exports = {
    splitFilename,
    TestResults,
    consolePrintTestResultsReportAndCallbackIfNeeded,
    compareTwoOject,
    TestFunctionConfig,
    readConfigAndRun,
}